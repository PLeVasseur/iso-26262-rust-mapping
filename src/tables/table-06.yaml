id: table-06
style: Table Grid
columns:
- key: principle
  title: Principle
- key: rust_mapping
  title: Rust mapping
- key: default_rule
  title: Default rule
- key: asil_c_d_tightening
  title: ASIL C/D tightening
- key: rationale
  title: Rationale
rows:
- principle: 1a One entry/one exit
  rust_mapping: Rust permits early returns (`return`, `?`) and multiple `match` arms; RAII reduces cleanup hazards.
  default_rule: Allow early return for error propagation (`?`). Avoid multiple ad-hoc early returns in complex functions;
    prefer structured control flow.
  asil_c_d_tightening: 'C/D: enforce ‘structured exits’: only `?` and single success return in complex functions unless justified.'
  rationale: Improves readability and supports traceability without reintroducing manual-cleanup patterns.
- principle: 1b No dynamic objects / online test
  rust_mapping: Allocation is explicit (`Box`, `Vec`, `String`, `Arc`, `Rc`). `no_std`/no-alloc profiles eliminate heap use
    entirely.
  default_rule: 'QM–B: allocation permitted with bounded capacity and failure handling. C/D: prefer no-alloc; otherwise require
    qualified allocator + fallible allocation patterns.'
  asil_c_d_tightening: 'C/D: forbid unbounded growth; require deterministic allocation strategy and resource usage evaluation.'
  rationale: Controls runtime failure modes and timing jitter due to allocation.
- principle: 1c Initialization of variables
  rust_mapping: Rust enforces definite initialization in safe code; `MaybeUninit` exists for controlled patterns.
  default_rule: All variables must be initialized before use. Prohibit use of uninitialized memory APIs; allow `MaybeUninit`
    only in Q modules with proof of initialization.
  asil_c_d_tightening: 'C/D: require Miri/UB checking of unsafe initialization paths; document initialization invariants.'
  rationale: Prevents undefined behavior and latent faults.
- principle: 1d No multiple use of variable names
  rust_mapping: Rust allows shadowing via `let`; can harm clarity.
  default_rule: Prohibit variable shadowing in safety-related code (`let x = …` reusing names). Allow shadowing only in tiny
    scopes (e.g., iterator adapters) with explicit lint suppression and justification.
  asil_c_d_tightening: 'C/D: no shadowing (hard error).'
  rationale: Avoids confusion during reviews and reduces mistake risk.
- principle: 1e Avoid global variables
  rust_mapping: Globals exist as `static` and `const`; mutable globals (`static mut`) require unsafe.
  default_rule: Prefer dependency injection and explicit state. Prohibit `static mut`. Restrict `static` to immutable data
    or to `OnceLock`/`LazyLock` with controlled initialization.
  asil_c_d_tightening: 'C/D: all global state must be justified, documented, and concurrency-safe; prefer partition-local
    state.'
  rationale: Global mutable state is a common source of interference and hidden coupling.
- principle: 1f Restricted use of pointers
  rust_mapping: References are non-null and lifetime-checked; raw pointers exist but require unsafe to dereference.
  default_rule: Use references (`&T`, `&mut T`) by default. Raw pointers only inside Q modules. Prohibit pointer arithmetic
    in application code.
  asil_c_d_tightening: 'C/D: require formal argument and independent review for any raw-pointer deref; ban `offset`/`add`
    unless proven safe.'
  rationale: Reduces memory safety hazards.
- principle: 1g No implicit conversions
  rust_mapping: Rust has no implicit numeric conversions; but has `Deref` coercions and `as` casts.
  default_rule: Restrict `as` to safe, non-lossy cases; require `TryFrom/TryInto` for narrowing. Avoid relying on `Deref`
    coercions in public APIs (make types explicit).
  asil_c_d_tightening: 'C/D: ban lossy casts; require dedicated conversion functions with tests for boundary cases.'
  rationale: Prevents truncation/sign errors and clarifies data flow.
- principle: 1h No hidden data/control flow
  rust_mapping: No exceptions; but macros, trait objects, and `Drop` can hide effects.
  default_rule: Restrict macros that introduce control flow; require explicit error handling (`Result`). Document `Drop` side
    effects. Restrict dynamic dispatch (`dyn Trait`) in critical timing paths.
  asil_c_d_tightening: 'C/D: macro allowlist; no custom proc macros unless qualified; require audit of `Drop` and dynamic
    dispatch.'
  rationale: Supports comprehension and verification.
- principle: 1i No unconditional jumps
  rust_mapping: Rust has no `goto`; `break`/`continue` are structured; labels exist.
  default_rule: Allow structured `break`/`continue`. Restrict labelled `break`/`continue` to cases where they simplify nesting;
    otherwise refactor.
  asil_c_d_tightening: 'C/D: require justification for labels; no label-based flow spanning large blocks.'
  rationale: Maintains structured control flow.
- principle: 1j No recursion (or justify/bound)
  rust_mapping: Recursion permitted; no guaranteed tail-call optimization.
  default_rule: Prohibit unbounded recursion. Allow bounded recursion only with explicit maximum depth and stack usage analysis.
  asil_c_d_tightening: 'C/D: bounded recursion only; prefer iterative implementations.'
  rationale: Prevents stack overflow and supports WCET reasoning.
